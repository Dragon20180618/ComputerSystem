Intel x86-64 进行算术运算或逻辑运算时，若产生的运算结果的低8位中有偶数个1，会把一位的条件码(condition code)  PF (parity flag 奇偶标志) 设置为1，否则就设置为0。	C语言中计算这个信息需要至少7次移位、掩码、异或运算。但是C程序无法知道PF的值。可以在程序中插入几条汇编得到这个值。

# 在程序中插入汇编

**方法一：** 编写完整的函数，放进独立的汇编代码中，通过汇编器和链接器把它和用C语言书写的代码合并起来。

**方法二：** 使用GCC的内联汇编，通过asm伪指令可以在C程序中包含简短的汇编代码，与方法一相比，减少了与及其相关的代码量。

# 跟在指令后面的后缀

movb(传送字节)、movw（传送字）、movl（传送双字）、movq（传送四字）。

<br>w -> word

<br>l -> long word 因为32位数被看作长字，l也被用来表示8字节double双精度浮点数

<br>q -> quadra word 四个字联合

 # 高位置0

在64位操作系统中,含有16个8字节(4字)寄存器.如果一条指令不够8字节,只有四字节,那么其他4字节高位置0.<br>

什么是高位置0,在起始数据之前加零.相当于在二进制数的前面都设置为0

# 操作数 指示符

%rsp 运行时栈结束位置.<br>

大多数指令有一个或多个操作数(operand), 指示出一个操作要使用的源数据的值, 和放置结果的目的位置. 可以直接以常数形式给出,或是从寄存器或内存中读出.结果存在寄存器或内存中.

## 操作数分三类:

### 立即数immediate

表示常数值. 在ATT格式中:$+整数 如 $-577, $0x1F, $01F. 不同指令有不同的立即数范围.

汇编器会选择最紧凑的方式进行数值编码. 

### 寄存器register

16个寄存器的 低位1字节, 2字节, 4字节, 8字节 中的一个作为操作数.

分别对应 8位, 16位, 32位, 64位.

R[r<sub>a</sub>] 寻址

### 内存引用

通过计算访问内存位置, 有一种办法, 将内存看做一个很大的数组. M<sub>b</sub>[Addr]表示 读取从位置Addr开始的b个字节, 为了简便, 通常省去下标b

当然,内存引用还有其他很多寻址模式. Imm(r<sub>b</sub>,  r<sub>i</sub>  , s)是最常用的形式.

**r<sub>b</sub>**    基址寄存器

**r<sub>i</sub> **    编址寄存器

**s**      比例因子  只能是1,2,4,8中的一个