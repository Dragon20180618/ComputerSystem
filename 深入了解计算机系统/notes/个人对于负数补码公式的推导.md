# 推导负数反码

在刚开始研究二进制的时候，教材和课程都会叫我们如何计算补码：

**正数的补码就是本身**

**负数的补码是反码+1**

### 没听过其他人讲解反数反码推导过程，所以引发了我的好奇心

所以我对着这3组二进制数字转换盯了许久

| 原码 | 1001 | 1010 | 1000 |
| ---- | ---- | ---- | ---- |
| 反码 | 1110 | 1101 | 1111 |
| 补码 | 1111 | 1110 | 0000 |

直接对这数字发呆，并没有得出什么规律，于是我开始计算

发现1001与反码1110后面的三位是相加得111的关系，和最高位的权值的绝对值正好差1，

**下面说明有负号负数补码的解释方法**

以1110为例：

**1110->十进制：**-（1\*2的3次方）+（1\*2的2次方）+（1*2的1次方）+（0\*2的0次方）

第一位的值为-2的n-1次方，但其他位为正值

**回到公式推导的讨论**

可知1111的值为-1而不是0

所以单纯用异或来得出反码与原来差1，既然差1，我们直接将1加到反码之中即可得到负数补码。

## 没错，我感觉还得加点注释

在高级语言中的有符号数和在存储器中储存的数据有部分差别，差别就在负数上

eg：程序中的1001 表示 -1，在存储器中为-8+1=-7。存储器存的是原数值的补码。